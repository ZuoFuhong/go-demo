package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

/*
    内存地址
      内存地址只是一个编号，代表一个内存空间。那么这个空间是多大呢？原来在计算机中存储器的容量是以字节为基本单位的。也就是说一个
      内存地址代表一个字节（8bit）的存储空间。

      内存是把8个bit排成1组，每1组成为1个单位，大小是1byte(字节），CPU每一次只能访问1个byte，而不能单独去访问具体的1个bit。
      1个byte（字节）就是内存的最小的IO单位。

      32位系统里内存地址长度是32位，所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000 0000 到 1111 1111 1111
      1111 1111 1111 1111 1111（Ox00000000 ~ OxFFFFFFFF)，也就是可以寻址2^32个地址，每个地址对应一个8bit的的内存单位。

      例如经常说32位的操作系统最多支持4GB的内存空间，也就是说CPU只能寻址2的32次方（4GB），注意这里的4GB是以Byte为单位的，不是
      bit。也就是说有4G = 4*1024M（Byte）= 4*1024*1024Kb(Byte) = 4*1024*1024*1024Byte(8bit)，即2的32次方个8bit单位。

      总结：内存地址是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据。


    高位/低位字节
      一般一个16位（双字节）的数据，比如：FF1A（16进制），那么高位字节就是FF，低位是1A
      如果是32位的数据，比如：3F68415B，高位字（不是字节）是3F68，低位字是415B。
      右边是低位，左边是高位


	字节序
	  一个字节中还包含8个bit (bit = binary digit)，在一个32位的CPU中“字长”为32个bit，也就是4个byte。在这样的CPU中，总是以
      4字节对齐的方式来读取或写入内存，那么同样这4个字节的数据是以什么顺序保存在内存中的呢？

      字节序包括：大端序和小端序，为什么要这么麻烦还要分门别类呢？举个例子，255用二进制表达就是1111 1111，再加1就是1 0000 0000，
      多了一个1出来，显然我们需要再用额外的一个字节来存放这个1，但是这个1要存放在第一个字节还是第二个字节呢？这时候因为人们选择的
      不同，就出现了大端序和小端序的差异。

      大端序的高字节存在低地址，低字节存在高地址，小端序相反，网络序一般为大端序。

      在读内存时一般从低字节向高字节读取。

      如一个long型数据0x12345678
      大端字节序：
	  内存低地址--> 0x12
                   0x34
　　　　　　         0x56
      内存高地址--> 0x78

      小端字节序：
      内存低地址--> 0x78
　　　　　　　       0x56
　　　　　　　       0x34
      内存高地址--> 0x12
*/
func main() {
	var i uint32 = 1234

	// 小端字节序
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, i)
	fmt.Printf("LittleEndian(%d) :", i)
	for _, bin := range b {
		fmt.Printf("%02X ", bin)
	}
	fmt.Printf("\n")

	// 大端字节序
	fmt.Printf("BigEndian(%d) :", i)
	binary.BigEndian.PutUint32(b, i)
	for _, bin := range b {
		fmt.Printf("%02X ", bin)
	}
	fmt.Printf("\n")

	// []byte 2 uint32
	bytesBuffer := bytes.NewBuffer(b)
	var j uint32
	_ = binary.Read(bytesBuffer, binary.BigEndian, &j)
	fmt.Println("j = ", j)
}
